<?php
// generated by Symfony (php bin/console make:entity) 
// @author ali-kemal.yalama ( ali-kemal.yalama@iubh.de ) 
namespace App\Repository;

use App\Entity\User;
use App\Entity\Fehler;
use Doctrine\Persistence\ManagerRegistry;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;

/**
 * @method Fehler|null find($id, $lockMode = null, $lockVersion = null)
 * @method Fehler|null findOneBy(array $criteria, array $orderBy = null)
 * @method Fehler[]    findAll()
 * @method Fehler[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class FehlerRepository extends ServiceEntityRepository
{
    public function __construct( ManagerRegistry $registry )
    {
        parent::__construct ( $registry, Fehler::class );
    }

    //Wir nutzen die Repositories, da ja dinge wie der QueryBuilder geerbt werden

    /**
     * Admin und Verwaltung sollen zugriff auf alle Fehler haben
     * Um Fehler aller Zustaende abzugreifen, nimm einfach "all" fuer status
     * 
     * status ist ein string
     */
    public function findAllByUserAndStatus ( User $user, $status ) 
    {
        $query = $this -> createQueryBuilder ( 'f' );

        $query = $this 
            -> addWheres                ( $query, $user      )
            -> setParameter             ( 'status',  $status ) 
            -> getQuery                 () 
            -> useQueryCache            ( true )
            -> useResultCache           ( true )
            -> setResultCacheLifetime   ( 60 )
        ;

        return $query;
    }


    /**
     * Counts all Fehler by Status
     */
    public function countAllByUserAndStatus ( $user, $status ) 
    {
        $query = $this -> createQueryBuilder ( 'f' );

        $query -> select ( "count (f.id) " );
        $query = $this -> addWheres ( $query, $user );
        $query -> setParameter ( 'status', $status     );

        return $query -> getQuery () -> useQueryCache ( true )   -> useResultCache ( true ) -> setResultCacheLifetime   ( 60 ) -> getSingleScalarResult ();  
    }

    private function addWheres  ( $query, $user )
    {
        if ( $user -> isAdmin () || $user -> isVerwaltung () )
            $query -> andWhere     ( 'f.status IN (:status)' );

        if ( $user -> isStudent () )
            $query
                -> andWhere     ( 'f.status IN (:status) AND f.einreicher IN (:studentId)' )
                -> setParameter ( 'studentId', $user -> getId ()     );

        if ( $user -> isTutor () )
        {
            $tutorModule = $user -> getOnlyIdsFromTutorIn ();
            $query
                -> andWhere     ( 'f.status IN (:status) AND f.einreicher IN (:module)' )
                -> setParameter ( 'module', $tutorModule, \Doctrine\DBAL\Connection::PARAM_STR_ARRAY );
        }

        return $query;
    }

    /* 
        Fehler by User und jeweils nach Status
        Offene Fehler
    */
    public function countAllByUserAndOpen       ( User $user ) 
    {
        return $this -> countAllByUserAndStatus ($user, "OPEN"       );
    }

    /*
        Fehler by User und jeweils nach Status
        Geschlossene Fehler
    */
    public function countAllByUserAndClosed     ( User $user )
    {
        return $this -> countAllByUserAndStatus ($user, "CLOSED"     );
    }
    
    /*
        Fehler by User und jeweils nach Status
        Wartend Fehler
    */
    public function countAllByUserAndWaiting    ( User $user ) 
    {
        return $this -> countAllByUserAndStatus ($user, "WAITING"    );
    }

    /*
        Fehler by User und jeweils nach Status
        Eskalierte Fehler
    */
    public function countAllByUserAndESCALATED  ( User $user ) 
    {
        return $this -> countAllByUserAndStatus ($user, "ESCALATED"  );
    }

    public function getAllFehlerForEscalation () 
    {
        $queryBuilder = $this -> createQueryBuilder ( 'f' );

        $query = $queryBuilder
            -> andWhere                 ( "f.status in ('OPEN', 'WAITING') AND date_diff(current_date(), f.datumLetzteAenderung) > 4" )
            -> getQuery                 ()
            -> useQueryCache            ( true )
            -> useResultCache           ( false )
            -> getResult                ()
        ;
        
        return $query;
    }

    public function getUnbearbeitetTage ( $fehlerId ) 
    {
        if ( $fehlerId <= 0 )
            return -1;
        
        $query = $this -> createQueryBuilder ( 'f' );

        $k =  $query
            -> select                   ( "date_diff(current_date(), f.datumLetzteAenderung)" )
            -> AndWhere                 ( "f.id = :fehlerId" )
            -> setParameter             ( 'fehlerId', $fehlerId )
            -> getQuery                 ()
            -> useQueryCache            ( true )
            -> useResultCache           ( false )
            -> setResultCacheLifetime   ( 60   )
            -> getSingleScalarResult    ()
        ;

        return $k;
    }
}
